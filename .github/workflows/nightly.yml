name: Nightly

on:
  schedule:
    - cron: "17 3 * * *"
  workflow_dispatch:
    inputs:
      tag_override:
        description: Optional tag override for manual runs (avoid nightly-YYYY-MM-DD to not interfere with real nightlies)
        required: false
        type: string

permissions:
  contents: read

jobs:
  select_spec:
    runs-on: ubuntu-latest
    outputs:
      should_publish: ${{ steps.select.outputs.should_publish }}
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Compute tag
        id: tag
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ inputs.tag_override }}"
          if [ -z "$TAG" ]; then
            TAG="nightly-$(date -u +%Y-%m-%d)"
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Select latest green SHAs
        id: select
        shell: bash
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          TAG="${{ steps.tag.outputs.tag }}"
          # Idempotency: if this tag already exists, do nothing.
          if gh release view "$TAG" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            echo "should_publish=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mkdir -p out
          set +e
          python scripts/select_latest_green.py --template release-specs/nightly.template.json --out out/release-spec.json --tag "$TAG"
          RC=$?
          set -e

          if [ "$RC" -eq 0 ]; then
            echo "should_publish=1" >> "$GITHUB_OUTPUT"
          elif [ "$RC" -eq 2 ]; then
            echo "should_publish=0" >> "$GITHUB_OUTPUT"
            exit 0
          else
            exit "$RC"
          fi

      - name: Upload spec
        if: steps.select.outputs.should_publish == '1'
        uses: actions/upload-artifact@v4
        with:
          name: nightly-release-spec
          path: out/release-spec.json

  plan:
    name: Plan (reuse vs build)
    runs-on: ubuntu-latest
    needs: [select_spec]
    if: needs.select_spec.outputs.should_publish == '1'
    outputs:
      build_bundles: ${{ steps.flags.outputs.build_bundles }}
      build_firmware_default: ${{ steps.flags.outputs.build_firmware_default }}
      build_firmware_bitwig: ${{ steps.flags.outputs.build_firmware_bitwig }}
      build_bitwig_extension: ${{ steps.flags.outputs.build_bitwig_extension }}

    steps:
      - name: Checkout distribution (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download release spec
        uses: actions/download-artifact@v4
        with:
          name: nightly-release-spec
          path: spec

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Compute reuse plan
        shell: bash
        env:
          GITHUB_TOKEN: ${{ github.token }}
          # Public key for nightly (not secret).
          # Keep in sync with the key embedded in ms-manager.
          MS_DIST_ED25519_PK: voOksaS+NoUkEy9c8YunbTwPnb1dlXCyEJ9Yy07233A=
        run: |
          set -euo pipefail
          mkdir -p out
          python scripts/build_manifest_with_reuse.py plan \
            --spec spec/release-spec.json \
            --out out/reuse-plan.json \
            --repo "${GITHUB_REPOSITORY}" \
            --workspace-root .

      - name: Export plan flags
        id: flags
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          p = json.load(open('out/reuse-plan.json', 'r', encoding='utf-8'))
          b = p.get('build', {})
          def flag(key: str) -> int:
              return 1 if b.get(key) is True else 0
          print(f"build_bundles={flag('bundles')}")
          print(f"build_firmware_default={flag('firmware_default')}")
          print(f"build_firmware_bitwig={flag('firmware_bitwig')}")
          print(f"build_bitwig_extension={flag('bitwig_extension')}")
          PY

      - name: Upload plan
        uses: actions/upload-artifact@v4
        with:
          name: reuse-plan
          path: out/reuse-plan.json

  build_bundles:
    name: Build bundles (${{ matrix.bundle_os }}-${{ matrix.arch }})
    needs: [select_spec, plan]
    if: needs.select_spec.outputs.should_publish == '1' && needs.plan.outputs.build_bundles == '1'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: windows-latest
            rust_target: x86_64-pc-windows-msvc
            bundle_os: windows
            arch: x86_64
            exe: .exe
          - runner: ubuntu-latest
            rust_target: x86_64-unknown-linux-gnu
            bundle_os: linux
            arch: x86_64
            exe: ""
          - runner: macos-15-intel
            rust_target: x86_64-apple-darwin
            bundle_os: macos
            arch: x86_64
            exe: ""
          - runner: macos-latest
            rust_target: aarch64-apple-darwin
            bundle_os: macos
            arch: arm64
            exe: ""

    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Download release spec
        uses: actions/download-artifact@v4
        with:
          name: nightly-release-spec
          path: spec

      - name: Read release spec
        id: spec
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json

          spec = json.load(open('spec/release-spec.json', 'r', encoding='utf-8'))
          repos = {r['id']: r['sha'] for r in spec['repos']}
          print(f"loader_sha={repos['loader']}")
          print(f"bridge_sha={repos['oc-bridge']}")
          PY

      - name: Checkout loader
        uses: actions/checkout@v4
        with:
          repository: petitechose-midi-studio/loader
          ref: ${{ steps.spec.outputs.loader_sha }}
          path: src/loader

      - name: Checkout oc-bridge
        uses: actions/checkout@v4
        with:
          repository: open-control/bridge
          ref: ${{ steps.spec.outputs.bridge_sha }}
          path: src/oc-bridge

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Install Linux system deps
        if: matrix.bundle_os == 'linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y libudev-dev libusb-1.0-0-dev

      - name: Build loader
        shell: bash
        env:
          CARGO_PROFILE_RELEASE_OPT_LEVEL: z
          CARGO_PROFILE_RELEASE_LTO: "true"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: abort
          CARGO_PROFILE_RELEASE_STRIP: symbols
          CARGO_PROFILE_RELEASE_DEBUG: "0"
        run: |
          set -euo pipefail
          cargo build --release --target "${{ matrix.rust_target }}" --no-default-features --features cli
        working-directory: src/loader

      - name: Build oc-bridge
        shell: bash
        env:
          CARGO_PROFILE_RELEASE_OPT_LEVEL: z
          CARGO_PROFILE_RELEASE_LTO: "true"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: abort
          CARGO_PROFILE_RELEASE_STRIP: symbols
          CARGO_PROFILE_RELEASE_DEBUG: "0"
        run: |
          set -euo pipefail
          cargo build --release --target "${{ matrix.rust_target }}"
        working-directory: src/oc-bridge

      - name: Package bundle
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist
          LOADER="src/loader/target/${{ matrix.rust_target }}/release/midi-studio-loader${{ matrix.exe }}"
          BRIDGE="src/oc-bridge/target/${{ matrix.rust_target }}/release/oc-bridge${{ matrix.exe }}"
          test -f "$LOADER"
          test -f "$BRIDGE"
          OUT="dist/midi-studio-${{ matrix.bundle_os }}-${{ matrix.arch }}-bundle.zip"
          python scripts/package_bundle.py --out "$OUT" --loader "$LOADER" --oc-bridge "$BRIDGE" --oc-bridge-config "src/oc-bridge/config"

      - name: Upload bundle
        uses: actions/upload-artifact@v4
        with:
          name: midi-studio-${{ matrix.bundle_os }}-${{ matrix.arch }}-bundle
          path: dist/midi-studio-${{ matrix.bundle_os }}-${{ matrix.arch }}-bundle.zip

  release:
    runs-on: ubuntu-latest
    needs: [select_spec, plan, build_bundles, build_integrations]
    if: >-
      ${{
        always() &&
        needs.select_spec.outputs.should_publish == '1' &&
        needs.plan.result == 'success' &&
        (
          needs.plan.outputs.build_bundles == '1' ||
          needs.plan.outputs.build_firmware_default == '1' ||
          needs.plan.outputs.build_firmware_bitwig == '1' ||
          needs.plan.outputs.build_bitwig_extension == '1'
        ) &&
        (needs.build_bundles.result == 'success' || needs.build_bundles.result == 'skipped') &&
        (needs.build_integrations.result == 'success' || needs.build_integrations.result == 'skipped')
      }}
    environment: nightly
    permissions:
      contents: write
    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Download bundles
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Download release spec
        uses: actions/download-artifact@v4
        with:
          name: nightly-release-spec
          path: spec

      - name: Flatten artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist_flat
          find dist -maxdepth 5 -type f \( -name '*.zip' -o -name '*.hex' -o -name '*.bwextension' \) -print -exec cp '{}' dist_flat/ \;
          ls -la dist_flat || true

      - name: Locate reuse plan
        id: plan
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import glob
          paths = glob.glob('dist/**/reuse-plan.json', recursive=True)
          if not paths:
            raise SystemExit('reuse-plan.json not found in downloaded artifacts')
          print(f"path={paths[0]}")
          PY

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Build manifest (with reuse)
        shell: bash
        run: |
          set -euo pipefail
          python scripts/build_manifest_with_reuse.py build \
            --spec spec/release-spec.json \
            --dist dist_flat \
            --plan "${{ steps.plan.outputs.path }}" \
            --out manifest.json

      - name: Sign manifest (nightly)
        shell: bash
        env:
          MS_DIST_ED25519_SK: ${{ secrets.MS_DIST_ED25519_SK_NIGHTLY }}
        run: |
          set -euo pipefail
          cargo run -p ms-dist-manifest -- sign --in manifest.json --out manifest.json.sig

      - name: Verify manifest signature
        shell: bash
        env:
          MS_DIST_ED25519_SK: ${{ secrets.MS_DIST_ED25519_SK_NIGHTLY }}
        run: |
          set -euo pipefail
          PK=$(cargo run -p ms-dist-manifest -- pubkey)
          MS_DIST_ED25519_PK="$PK" cargo run -p ms-dist-manifest -- verify --in manifest.json --sig manifest.json.sig

      - name: Verify manifest assets (download reused URLs)
        shell: bash
        run: |
          set -euo pipefail
          python scripts/verify_manifest_assets.py --manifest manifest.json --assets-dir dist_flat --fetch-urls

      - name: Create GitHub Release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          ASSETS=(dist_flat/*.zip dist_flat/*.hex dist_flat/*.bwextension)
          gh release create "${{ needs.select_spec.outputs.tag }}" \
            "${ASSETS[@]}" \
            manifest.json manifest.json.sig \
            --title "${{ needs.select_spec.outputs.tag }}" \
            --notes "channel=nightly" \
            --prerelease \
            --target "${GITHUB_SHA}" \
            --repo "${GITHUB_REPOSITORY}"

  build_integrations:
    name: Build firmware + Bitwig extension
    needs: [plan, select_spec]
    if: >-
      ${{
        needs.select_spec.outputs.should_publish == '1' &&
        (
          needs.plan.outputs.build_firmware_default == '1' ||
          needs.plan.outputs.build_firmware_bitwig == '1' ||
          needs.plan.outputs.build_bitwig_extension == '1'
        )
      }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Download release spec
        uses: actions/download-artifact@v4
        with:
          name: nightly-release-spec
          path: spec

      - name: Read release spec
        id: spec
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          spec = json.load(open('spec/release-spec.json', 'r', encoding='utf-8'))
          repos = {r['id']: r['sha'] for r in spec.get('repos', [])}
          def get(repo_id: str) -> str:
              sha = repos.get(repo_id)
              if not isinstance(sha, str) or len(sha) != 40:
                  raise SystemExit(f"missing/invalid sha for {repo_id}: {sha!r}")
              return sha
          print(f"core_sha={get('core')}")
          print(f"bitwig_sha={get('plugin-bitwig')}")
          PY

      - name: Checkout core
        if: needs.plan.outputs.build_firmware_default == '1' || needs.plan.outputs.build_firmware_bitwig == '1'
        uses: actions/checkout@v4
        with:
          repository: petitechose-midi-studio/core
          ref: ${{ steps.spec.outputs.core_sha }}
          path: src/midi-studio/core

      - name: Checkout plugin-bitwig
        if: needs.plan.outputs.build_firmware_bitwig == '1' || needs.plan.outputs.build_bitwig_extension == '1'
        uses: actions/checkout@v4
        with:
          repository: petitechose-midi-studio/plugin-bitwig
          ref: ${{ steps.spec.outputs.bitwig_sha }}
          path: src/midi-studio/plugin-bitwig

      - name: Install PlatformIO
        if: needs.plan.outputs.build_firmware_default == '1' || needs.plan.outputs.build_firmware_bitwig == '1'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install platformio

      - name: Build core firmware (default)
        if: needs.plan.outputs.build_firmware_default == '1'
        shell: bash
        run: |
          set -euo pipefail
          python -m platformio run -e release
        working-directory: src/midi-studio/core

      - name: Build bitwig firmware
        if: needs.plan.outputs.build_firmware_bitwig == '1'
        shell: bash
        run: |
          set -euo pipefail
          python -m platformio run -e release
        working-directory: src/midi-studio/plugin-bitwig

      - name: Install Java
        if: needs.plan.outputs.build_bitwig_extension == '1'
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Build Bitwig extension
        if: needs.plan.outputs.build_bitwig_extension == '1'
        shell: bash
        run: |
          set -euo pipefail
          mvn package -Pmanual -Dmaven.compiler.release=21
        working-directory: src/midi-studio/plugin-bitwig/host

      - name: Collect artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist
          if [ "${{ needs.plan.outputs.build_firmware_default }}" = "1" ]; then
            cp "src/midi-studio/core/.pio/build/release/firmware.hex" "dist/midi-studio-default-firmware.hex"
          fi
          if [ "${{ needs.plan.outputs.build_firmware_bitwig }}" = "1" ]; then
            cp "src/midi-studio/plugin-bitwig/.pio/build/release/firmware.hex" "dist/midi-studio-bitwig-firmware.hex"
          fi
          if [ "${{ needs.plan.outputs.build_bitwig_extension }}" = "1" ]; then
            cp "src/midi-studio/plugin-bitwig/host/target/midi_studio.bwextension" "dist/midi_studio.bwextension"
          fi
          ls -la dist

      - name: Upload integrations
        uses: actions/upload-artifact@v4
        with:
          name: midi-studio-integrations
          path: dist
