name: Publish

on:
  workflow_dispatch:
    inputs:
      channel:
        description: stable or beta
        required: true
        type: choice
        options:
          - stable
          - beta
      tag:
        description: Release tag (e.g. v0.1.0)
        required: true
        type: string
      spec_path:
        description: Path to release spec JSON in this repo
        required: true
        type: string

permissions:
  contents: read

jobs:
  plan:
    name: Plan (reuse vs build)
    runs-on: ubuntu-latest
    outputs:
      build_bundles: ${{ steps.flags.outputs.build_bundles }}
      build_firmware_default: ${{ steps.flags.outputs.build_firmware_default }}
      build_firmware_bitwig: ${{ steps.flags.outputs.build_firmware_bitwig }}
      build_bitwig_extension: ${{ steps.flags.outputs.build_bitwig_extension }}

    steps:
      - name: Checkout distribution (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Compute reuse plan
        shell: bash
        env:
          GITHUB_TOKEN: ${{ github.token }}
          # Public key for stable/beta (not secret).
          # Keep in sync with the key embedded in ms-manager.
          MS_DIST_ED25519_PK: 2rHtM99leFGTpjZ8fZHNCdGXlEKmAw6hEyaat1uGO3M=
        run: |
          set -euo pipefail
          mkdir -p out
          python scripts/build_manifest_with_reuse.py plan \
            --spec "${{ inputs.spec_path }}" \
            --out out/reuse-plan.json \
            --repo "${GITHUB_REPOSITORY}" \
            --workspace-root .

      - name: Export plan flags
        id: flags
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          p = json.load(open('out/reuse-plan.json', 'r', encoding='utf-8'))
          b = p.get('build', {})
          def flag(key: str) -> int:
              return 1 if b.get(key) is True else 0
          print(f"build_bundles={flag('bundles')}")
          print(f"build_firmware_default={flag('firmware_default')}")
          print(f"build_firmware_bitwig={flag('firmware_bitwig')}")
          print(f"build_bitwig_extension={flag('bitwig_extension')}")
          PY

      - name: Upload plan
        uses: actions/upload-artifact@v4
        with:
          name: reuse-plan
          path: out/reuse-plan.json

  build_bundles:
    name: Build bundles (${{ matrix.bundle_os }}-${{ matrix.arch }})
    needs: [plan]
    if: needs.plan.outputs.build_bundles == '1'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: windows-latest
            rust_target: x86_64-pc-windows-msvc
            bundle_os: windows
            arch: x86_64
            exe: .exe
          - runner: ubuntu-latest
            rust_target: x86_64-unknown-linux-gnu
            bundle_os: linux
            arch: x86_64
            exe: ""
          - runner: macos-15-intel
            rust_target: x86_64-apple-darwin
            bundle_os: macos
            arch: x86_64
            exe: ""
          - runner: macos-latest
            rust_target: aarch64-apple-darwin
            bundle_os: macos
            arch: arm64
            exe: ""


    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Read release spec
        id: spec
        shell: bash
        run: |
          set -euo pipefail
          test -f "${{ inputs.spec_path }}"
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import sys

          path = "${{ inputs.spec_path }}"
          spec = json.load(open(path, "r", encoding="utf-8"))

          def get_sha(repo_id: str) -> str:
              for r in spec.get("repos", []):
                  if r.get("id") == repo_id:
                      sha = r.get("sha")
                      if not isinstance(sha, str) or len(sha) != 40:
                          raise SystemExit(f"invalid sha for {repo_id}: {sha!r}")
                      return sha
              raise SystemExit(f"missing repo id in spec: {repo_id}")

          print(f"loader_sha={get_sha('loader')}")
          print(f"bridge_sha={get_sha('oc-bridge')}")
          PY

      - name: Checkout loader
        uses: actions/checkout@v4
        with:
          repository: petitechose-midi-studio/loader
          ref: ${{ steps.spec.outputs.loader_sha }}
          path: src/loader

      - name: Checkout oc-bridge
        uses: actions/checkout@v4
        with:
          repository: open-control/bridge
          ref: ${{ steps.spec.outputs.bridge_sha }}
          path: src/oc-bridge

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Install Linux system deps
        if: matrix.bundle_os == 'linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y libudev-dev libusb-1.0-0-dev

      - name: Build loader
        shell: bash
        env:
          CARGO_PROFILE_RELEASE_OPT_LEVEL: z
          CARGO_PROFILE_RELEASE_LTO: "true"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: abort
          CARGO_PROFILE_RELEASE_STRIP: symbols
          CARGO_PROFILE_RELEASE_DEBUG: "0"
        run: |
          set -euo pipefail
          cargo build --release --target "${{ matrix.rust_target }}" --no-default-features --features cli
        working-directory: src/loader

      - name: Build oc-bridge
        shell: bash
        env:
          CARGO_PROFILE_RELEASE_OPT_LEVEL: z
          CARGO_PROFILE_RELEASE_LTO: "true"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: abort
          CARGO_PROFILE_RELEASE_STRIP: symbols
          CARGO_PROFILE_RELEASE_DEBUG: "0"
        run: |
          set -euo pipefail
          cargo build --release --target "${{ matrix.rust_target }}"
        working-directory: src/oc-bridge

      - name: Package bundle
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist
          LOADER="src/loader/target/${{ matrix.rust_target }}/release/midi-studio-loader${{ matrix.exe }}"
          BRIDGE="src/oc-bridge/target/${{ matrix.rust_target }}/release/oc-bridge${{ matrix.exe }}"
          test -f "$LOADER"
          test -f "$BRIDGE"
          OUT="dist/midi-studio-${{ matrix.bundle_os }}-${{ matrix.arch }}-bundle.zip"
          python scripts/package_bundle.py --out "$OUT" --loader "$LOADER" --oc-bridge "$BRIDGE" --oc-bridge-config "src/oc-bridge/config"

      - name: Upload bundle
        uses: actions/upload-artifact@v4
        with:
          name: midi-studio-${{ matrix.bundle_os }}-${{ matrix.arch }}-bundle
          path: dist/midi-studio-${{ matrix.bundle_os }}-${{ matrix.arch }}-bundle.zip

  assemble:
    name: Assemble dist (copy reuse) + validate
    runs-on: ubuntu-latest
    needs: [plan, build_bundles, build_integrations]
    if: >-
      ${{
        always() &&
        needs.plan.result == 'success' &&
        (needs.build_bundles.result == 'success' || needs.build_bundles.result == 'skipped') &&
        (needs.build_integrations.result == 'success' || needs.build_integrations.result == 'skipped')
      }}

    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Flatten artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist_flat
          find dist -maxdepth 5 -type f \( -name '*.zip' -o -name '*.hex' -o -name '*.bwextension' \) -print -exec cp '{}' dist_flat/ \;
          ls -la dist_flat || true

      - name: Locate reuse plan
        id: plan
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import glob
          paths = glob.glob('dist/**/reuse-plan.json', recursive=True)
          if not paths:
            raise SystemExit('reuse-plan.json not found in downloaded artifacts')
          print(f"path={paths[0]}")
          PY

      - name: Copy reuse plan
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          cp "${{ steps.plan.outputs.path }}" out/reuse-plan.json

      - name: Materialize reused assets (copy reuse)
        shell: bash
        run: |
          set -euo pipefail
          python scripts/build_manifest_with_reuse.py materialize \
            --spec "${{ inputs.spec_path }}" \
            --dist dist_flat \
            --plan out/reuse-plan.json

      - name: Validate dist against spec
        shell: bash
        run: |
          set -euo pipefail
          python scripts/validate_dist.py --spec "${{ inputs.spec_path }}" --dist dist_flat

      - name: Build manifest preview (with reuse)
        shell: bash
        run: |
          set -euo pipefail
          python scripts/build_manifest_with_reuse.py build \
            --spec "${{ inputs.spec_path }}" \
            --dist dist_flat \
            --plan out/reuse-plan.json \
            --out out/manifest.preview.json

      - name: Upload assembled dist
        uses: actions/upload-artifact@v4
        with:
          name: assembled-dist
          path: |
            dist_flat
            out/reuse-plan.json
            out/manifest.preview.json

  release:
    name: Sign and publish release
    runs-on: ubuntu-latest
    needs: [assemble]
    if: >-
      ${{
        always() &&
        needs.assemble.result == 'success'
      }}
    environment: release
    permissions:
      contents: write

    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Download assembled dist
        uses: actions/download-artifact@v4
        with:
          name: assembled-dist
          path: assembled

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache
        uses: Swatinem/rust-cache@v2

      - name: Build manifest (with reuse)
        shell: bash
        run: |
          set -euo pipefail
          python scripts/build_manifest_with_reuse.py build \
            --spec "${{ inputs.spec_path }}" \
            --dist assembled/dist_flat \
            --plan assembled/out/reuse-plan.json \
            --out manifest.json

      - name: Sign manifest
        shell: bash
        env:
          MS_DIST_ED25519_SK: ${{ secrets.MS_DIST_ED25519_SK }}
        run: |
          set -euo pipefail
          cargo run -p ms-dist-manifest -- sign --in manifest.json --out manifest.json.sig

      - name: Verify manifest signature
        shell: bash
        env:
          MS_DIST_ED25519_SK: ${{ secrets.MS_DIST_ED25519_SK }}
        run: |
          set -euo pipefail
          PK=$(cargo run -p ms-dist-manifest -- pubkey)
          MS_DIST_ED25519_PK="$PK" cargo run -p ms-dist-manifest -- verify --in manifest.json --sig manifest.json.sig

      - name: Create GitHub Release (draft)
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          shopt -s nullglob

          EXTRA_FLAGS=()
          if [ "${{ inputs.channel }}" = "beta" ]; then
            EXTRA_FLAGS+=("--prerelease")
          fi

          NOTES_ARGS=()
          NOTES_FILE="release-notes/${{ inputs.tag }}.md"
          if [ -f "$NOTES_FILE" ]; then
            NOTES_ARGS+=("--notes-file" "$NOTES_FILE")
          else
            NOTES_ARGS+=("--notes" "channel=${{ inputs.channel }}")
          fi

          ASSETS=(assembled/dist_flat/*.zip assembled/dist_flat/*.hex assembled/dist_flat/*.bwextension)
          gh release create "${{ inputs.tag }}" \
            "${ASSETS[@]}" \
            manifest.json manifest.json.sig \
            --title "${{ inputs.tag }}" \
            "${NOTES_ARGS[@]}" \
            --repo "${GITHUB_REPOSITORY}" \
            --target "${GITHUB_SHA}" \
            --draft \
            "${EXTRA_FLAGS[@]}"

      - name: Verify uploaded assets match manifest
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          MS_DIST_ED25519_SK: ${{ secrets.MS_DIST_ED25519_SK }}
        run: |
          set -euo pipefail
          rm -rf verify
          mkdir -p verify
          gh release download "${{ inputs.tag }}" --dir verify --repo "${GITHUB_REPOSITORY}"

          PK=$(cargo run -p ms-dist-manifest -- pubkey)
          MS_DIST_ED25519_PK="$PK" cargo run -p ms-dist-manifest -- verify --in verify/manifest.json --sig verify/manifest.json.sig
          python scripts/verify_manifest_assets.py --manifest verify/manifest.json --assets-dir verify

      - name: Publish GitHub Release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh release edit "${{ inputs.tag }}" --draft=false --repo "${GITHUB_REPOSITORY}"

  build_integrations:
    name: Build firmware + Bitwig extension
    needs: [plan]
    if: >-
      ${{
        needs.plan.outputs.build_firmware_default == '1' ||
        needs.plan.outputs.build_firmware_bitwig == '1' ||
        needs.plan.outputs.build_bitwig_extension == '1'
      }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout distribution
        uses: actions/checkout@v4

      - name: Read release spec
        id: spec
        shell: bash
        run: |
          set -euo pipefail
          test -f "${{ inputs.spec_path }}"
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          spec = json.load(open("${{ inputs.spec_path }}", "r", encoding="utf-8"))
          repos = {r["id"]: r["sha"] for r in spec.get("repos", [])}
          def get(repo_id: str) -> str:
              sha = repos.get(repo_id)
              if not isinstance(sha, str) or len(sha) != 40:
                  raise SystemExit(f"missing/invalid sha for {repo_id}: {sha!r}")
              return sha
          print(f"core_sha={get('core')}")
          print(f"bitwig_sha={get('plugin-bitwig')}")
          PY

      - name: Checkout core
        if: needs.plan.outputs.build_firmware_default == '1' || needs.plan.outputs.build_firmware_bitwig == '1'
        uses: actions/checkout@v4
        with:
          repository: petitechose-midi-studio/core
          ref: ${{ steps.spec.outputs.core_sha }}
          path: src/midi-studio/core

      - name: Checkout plugin-bitwig
        if: needs.plan.outputs.build_firmware_bitwig == '1' || needs.plan.outputs.build_bitwig_extension == '1'
        uses: actions/checkout@v4
        with:
          repository: petitechose-midi-studio/plugin-bitwig
          ref: ${{ steps.spec.outputs.bitwig_sha }}
          path: src/midi-studio/plugin-bitwig

      - name: Install PlatformIO
        if: needs.plan.outputs.build_firmware_default == '1' || needs.plan.outputs.build_firmware_bitwig == '1'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install platformio

      - name: Build core firmware (default)
        if: needs.plan.outputs.build_firmware_default == '1'
        shell: bash
        run: |
          set -euo pipefail
          python -m platformio run -e release
        working-directory: src/midi-studio/core

      - name: Build bitwig firmware
        if: needs.plan.outputs.build_firmware_bitwig == '1'
        shell: bash
        run: |
          set -euo pipefail
          python -m platformio run -e release
        working-directory: src/midi-studio/plugin-bitwig

      - name: Install Java
        if: needs.plan.outputs.build_bitwig_extension == '1'
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Build Bitwig extension
        if: needs.plan.outputs.build_bitwig_extension == '1'
        shell: bash
        run: |
          set -euo pipefail
          mvn package -Pmanual -Dmaven.compiler.release=21
        working-directory: src/midi-studio/plugin-bitwig/host

      - name: Collect artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist
          if [ "${{ needs.plan.outputs.build_firmware_default }}" = "1" ]; then
            cp "src/midi-studio/core/.pio/build/release/firmware.hex" "dist/midi-studio-default-firmware.hex"
          fi
          if [ "${{ needs.plan.outputs.build_firmware_bitwig }}" = "1" ]; then
            cp "src/midi-studio/plugin-bitwig/.pio/build/release/firmware.hex" "dist/midi-studio-bitwig-firmware.hex"
          fi
          if [ "${{ needs.plan.outputs.build_bitwig_extension }}" = "1" ]; then
            cp "src/midi-studio/plugin-bitwig/host/target/midi_studio.bwextension" "dist/midi_studio.bwextension"
          fi
          ls -la dist

      - name: Upload integrations
        uses: actions/upload-artifact@v4
        with:
          name: midi-studio-integrations
          path: dist
